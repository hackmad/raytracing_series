//! # Recursive ray tracer

extern crate clap;
extern crate rand;

mod algebra;
mod camera;
mod common;
mod material;
mod object;
mod scene;

use algebra::*;
use clap::{builder::EnumValueParser, Parser};
use common::*;
use object::*;
use scene::*;

/// Program configuration
#[derive(Parser, Clone)]
#[command(author, version, about, long_about = None)]
struct Config {
    /// Image height.
    #[arg(
        long = "image-width",
        short = 'w',
        value_name = "WIDTH",
        default_value_t = 200,
        help = "image width in pixels"
    )]
    pub image_width: u32,

    /// Image width.
    #[arg(
        long = "image-height",
        short = 'h',
        value_name = "HEIGHT",
        default_value_t = 100,
        help = "image height in pixels"
    )]
    pub image_height: u32,

    /// Samples per pixels for antialiasing.
    #[arg(
        long = "samples-per-pixel",
        short = 's',
        value_name = "SAMPLES",
        default_value_t = 100,
        help = "number of samples per pixel for antialiasing"
    )]
    pub samples_per_pixel: u32,

    /// Max recursion depth
    #[arg(
        long = "max-depth",
        short = 'd',
        value_name = "DEPTH",
        default_value_t = 50,
        help = "maximum depth of recursion"
    )]
    pub max_depth: u32,

    /// Scene to render.
    #[arg(
        long = "scene",
        value_name = "SCENE",
        value_parser = EnumValueParser::<Scenery>::new(),
        default_value = "random_spheres",
        help = "scene to render",
    )]
    pub scenery: Scenery,
}

/// Entry point for the recursive raytracer.
fn main() {
    let c = Config::parse();

    let s = Scene::new(c.scenery, c.image_width, c.image_height);

    println!("P3\n{} {}\n255", c.image_width, c.image_height);

    for j in (0..c.image_height).rev() {
        eprint!("Scan lines remaining: {}          \r", j);

        for i in 0..c.image_width {
            let mut colour = Vec3::zero().as_colour();

            for _s in 0..c.samples_per_pixel {
                let u = ((i as Float) + random()) / (c.image_width as Float);
                let v = ((j as Float) + random()) / (c.image_height as Float);

                let r = s.camera.get_ray(u, v);
                colour += ray_colour(&r, &s.world, c.max_depth);
            }

            let c = colour.to_colour_from_sample(c.samples_per_pixel).to_ppm();
            println!("{}", c);
        }
    }
    eprintln!("\nDone!");
}

/// Recursively traces a ray through the scene and generates the colour seen
/// at the image plane.
///
/// * `ray` - The ray.
/// * `world` - The list of geometric objects.
/// * `depth` - Maximum depth for recursion.
fn ray_colour(ray: &Ray, world: &HittableList, depth: u32) -> Colour {
    // Terminate the recursion if maximum depth is reached.
    if depth <= 0 {
        return Vec3::zero().as_colour();
    }

    // Note the 0.001 is used to avoid starting the ray inside the surface
    // caused due to floating point approximation errors generated by the
    // intersection routine.
    match world.hit(&ray, 0.001, INFINITY) {
        Some(rec) => {
            // If material did not absorb the ray and scattered it, continue
            // tracing the new ray.
            if let Some(sr) = rec.material.clone().scatter(ray, &rec) {
                ray_colour(&sr.scattered, world, depth - 1) * sr.attenuation
            } else {
                background_colour(ray)
            }
        }

        _ => background_colour(ray),
    }
}

/// Generate a gradient colour for the background.
///
/// * `ray` - The ray.
fn background_colour(ray: &Ray) -> Colour {
    let unit_direction = ray.direction.unit_vector();
    let t = 0.5 * (unit_direction.y() + 1.0);
    (Vec3::new(1.0, 1.0, 1.0) * (1.0 - t) + Vec3::new(0.5, 0.7, 1.0) * t).as_colour()
}

//! # Recursive ray tracer

extern crate clap;
extern crate rand;
extern crate rand_chacha;

mod algebra;
mod camera;
mod common;
mod material;
mod object;
mod scene;
mod texture;

use algebra::*;
use clap::{App, Arg};
use common::*;
use object::*;
use scene::*;
use std::rc::Rc;
use std::time::Instant;

/// Program configuration
struct Config {
    /// Image height
    image_width: u32,

    /// Image width
    image_height: u32,

    /// Samples per pixels for antialiasing
    samples_per_pixel: u32,

    /// Max recursion depth
    max_depth: u32,

    /// Scene to render
    scenery: Scenery,

    /// Enable bounding value hierarchy
    bvh_enabled: bool,

    /// Random number seed
    seed: Option<u64>,
}

/// Entry point for the recursive raytracer.
fn main() {
    let config = app_config();

    let rng = match config.seed {
        Some(seed) => new_seeded_rng(seed),
        None => new_thread_rng(),
    };

    let scene = Scene::new(
        config.scenery,
        config.image_width,
        config.image_height,
        config.bvh_enabled,
        Rc::clone(&rng),
    );

    let image_width = config.image_width as Float;
    let image_height = config.image_height as Float;
    let percent_step = 100.0 / image_height;

    let start = Instant::now();

    println!("P3\n{} {}\n255", config.image_width, config.image_height);

    for j in (0..config.image_height).rev() {
        let y = j as Float;

        let progress = percent_step * (image_height - y);
        eprint!("Progress: {:>6.2}%\r", progress);

        for i in 0..config.image_width {
            let x = i as Float;

            let mut colour = Colour::zero();

            for _s in 0..config.samples_per_pixel {
                let u = (x + rng.clone().float()) / image_width;
                let v = (y + rng.clone().float()) / image_height;

                let r = scene.camera.clone().get_ray(u, v);
                colour += ray_colour(&r, &scene.world, config.max_depth);
            }

            let c = colour
                .to_colour_from_sample(config.samples_per_pixel)
                .to_ppm();
            println!("{}", c);
        }
    }

    eprintln!("Done: {} seconds", start.elapsed().as_secs_f32());
}

/// Recursively traces a ray through the scene and generates the colour seen
/// at the image plane.
///
/// * `ray` - The ray.
/// * `world` - The list of geometric objects.
/// * `depth` - Maximum depth for recursion.
fn ray_colour(ray: &Ray, world: &RcHittable, depth: u32) -> Colour {
    // Terminate the recursion if maximum depth is reached.
    if depth <= 0 {
        return Colour::zero();
    }

    // Note the 0.001 is used to avoid starting the ray inside the surface
    // caused due to floating point approximation errors generated by the
    // intersection routine.
    match world.hit(&ray, 0.001, INFINITY) {
        Some(rec) => {
            // If material did not absorb the ray and scattered it, continue
            // tracing the new ray.
            if let Some(sr) = rec.material.clone().scatter(ray, &rec) {
                ray_colour(&sr.scattered, world, depth - 1) * sr.attenuation
            } else {
                background_colour(ray)
            }
        }

        _ => background_colour(ray),
    }
}

/// Generate a gradient colour for the background.
///
/// * `ray` - The ray.
fn background_colour(ray: &Ray) -> Colour {
    let unit_direction = ray.direction.unit_vector();
    let t = 0.5 * (unit_direction.y() + 1.0);
    Colour::new(1.0, 1.0, 1.0) * (1.0 - t) + Colour::new(0.5, 0.7, 1.0) * t
}

fn app_config() -> Config {
    let matches = App::new("Raytracing in One Weekend")
        .version("0.0.1")
        .arg(
            Arg::with_name("image_width")
                .short('w')
                .long("image_width")
                .value_name("WIDTH")
                .takes_value(true)
                .default_value("200")
                .about("image width in pixels"),
        )
        .arg(
            Arg::with_name("image_height")
                .short('h')
                .long("image_height")
                .value_name("HEIGHT")
                .takes_value(true)
                .default_value("100")
                .about("image height in pixels"),
        )
        .arg(
            Arg::with_name("samples_per_pixel")
                .short('s')
                .long("samples_per_pixel")
                .value_name("SAMPLES")
                .takes_value(true)
                .default_value("100")
                .about("number of samples per pixel for antialiasing"),
        )
        .arg(
            Arg::with_name("max_depth")
                .short('d')
                .long("max_depth")
                .value_name("DEPTH")
                .takes_value(true)
                .default_value("50")
                .about("maximum depth of recursion"),
        )
        .arg(
            Arg::with_name("scene")
                .long("scene")
                .value_name("SCENE")
                .takes_value(true)
                .possible_values(&[
                    "lambertian_diffuse",
                    "metal",
                    "dielectric",
                    "telephoto",
                    "wide_angle",
                    "defocus_blur",
                    "random_spheres",
                    "motion_blur",
                ])
                .default_value("random_spheres")
                .about("scene to render"),
        )
        .arg(
            Arg::with_name("bvh")
                .long("bvh")
                .value_name("BVH")
                .takes_value(false)
                .about("enable bounding volume hierarchy"),
        )
        .arg(
            Arg::with_name("seed")
                .long("seed")
                .value_name("SEED")
                .takes_value(true)
                .about("seed for rng number generator (debug)"),
        )
        .get_matches();

    let image_width = match matches.value_of("image_width") {
        Some(s) => s.parse::<u32>().unwrap(),
        _ => panic!("Invalid image width"),
    };

    let image_height = match matches.value_of("image_height") {
        Some(s) => s.parse::<u32>().unwrap(),
        _ => panic!("Invalid image height"),
    };

    let samples_per_pixel = match matches.value_of("samples_per_pixel") {
        Some(s) => s.parse::<u32>().unwrap(),
        _ => panic!("Invalid samples per pixel"),
    };

    let max_depth = match matches.value_of("max_depth") {
        Some(s) => s.parse::<u32>().unwrap(),
        _ => panic!("Invalid max depth"),
    };

    let scenery = match matches.value_of("scene") {
        Some(s) => match s {
            "lambertian_diffuse" => Scenery::LambertianDiffuse,
            "metal" => Scenery::Metal,
            "dielectric" => Scenery::Dielectric,
            "telephoto" => Scenery::Telephoto,
            "wide_angle" => Scenery::WideAngle,
            "defocus_blur" => Scenery::DefocusBlur,
            "random_spheres" => Scenery::RandomSpheres,
            "motion_blur" => Scenery::MotionBlur,
            s => panic!("Unknown scene {}", s),
        },
        _ => panic!("Invalid scene name"),
    };

    let bvh_enabled = matches.is_present("bvh");

    let seed = match matches.value_of("seed") {
        Some(s) => Some(s.parse::<u64>().unwrap()),
        _ => None,
    };

    Config {
        image_width,
        image_height,
        samples_per_pixel,
        max_depth,
        scenery,
        bvh_enabled,
        seed,
    }
}
